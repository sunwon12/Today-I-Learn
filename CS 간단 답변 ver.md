- **URI과 URL의 차이점**
    
    
    URI는 어떠한 자원인지 명시한 것이고 URL은 자원은 위치와 어떻게 접근하는지가 명시되어있습니다.
    
    ```java
    URI: /users/123 (리소스 식별)
    URL: https://api.example.com/users/123 (리소스 위치)
    
    ```
    
- **HTTP 메소드**
    - **GET메소드와 POST 메소드 차이점**
        
        POST 메소드와 달리 GET 메소드는 request body가 없어 넘겨줄 정보가 있다면 URL에 포함시켜 넘겨줍니다. 또한 GET 메소드는 멱등성이 있어 여러번 호출해도 같은 결과가 보장되지만, POST 메소드는 멱등성이 보장되어 있지 않아, 매 호출마다 결과가 달라질 수도 있습니다.
        
- 클라이언트가 웹사이트에 접속했을 때 일어나는 일련의 과정
    
    도메인 서버와 연결을 하기 위해서는 IP주소가 필요하기 때문에, Local DNS Cache를 조회해 도메인 서버에 IP 주소가 있는지 확인합니다. 만약 없다면 DNS 서버에서 도메인 서버에 IP주소를 가져옵니다. IP주소로 TCP 3Way handShake를 통해 연결을 합니다. 3Way handShake의 과정으로는 처음에 클라이언트가 SYN 패캣을 보내 연결 가능한지 물어봅니다. 연결이 가능하다면, 서버에서 SYN와 ACK로 응답을 합니다. 다시 클라이언트는 ACK를 보내 연결을 하겠다고 응답합니다. 이렇게 3WayHandSake가 끝난다면 HTTP 통신이 이루어지는고 종료될 때 4Way HandShake 과정이 일어납니다. 4-Way Handshake 과정으로는 먼저 클라이언트가 연결을 종료하겠다는 FIN을 보냅니다. 이를 받은 서버는 ACK로 응답하고, 자신의 통신이 끝날 때까지 기다립니다. 서버의 통신이 끝났다면 서버는 FIN을 클라이언트에게 보냅니다. 클라이언트는 확인했다는 ACK를 보내고 연결이 종료됩니다. 이때 클라이언트는 아직 서버로부터 받지 못한 데이터가 있을 수 있으므로 TIME_WAIT 상태로 일정 시간 대기합니다.
    만약 HTTPS라면 3-way-handshake 이후 SSL/TLS Handshake가 추가됩니다. 
    SSL/TLS hand shake는 클라이언트는 랜덤 데이터와 세션 ID를 넘기고 서버는 인증서, 암호화 알고리즘, 랜덤 데이터를 넘깁니다. 이 때, 클라이언트는 서버가 넘겨준 인증서가 안전한지 검증합니다. 안전하다면, 클라이언트는 pre-master secret를 생성해서 서버 공개키로 암호화하여 서버에게 넘겨줍니다. 서버는 복호화하여 pre-master secret를 획득합니다. 양쪽 모두 각자의 랜덤값과 pre-master secret를 합쳐 대칭키를 생성하고 대칭키를 이용해서 finshed 메시지를 교환함으로써 종료합니다. 이후 모든 요청은 대칭키로 암호화됩니다.
    
- JVM이란
    
    자바 프로그램을 실행시키는 가상머신입니다. JVM의 특징으로는 OS와 상관없이 실행가능한다는 장점이 있습니다. 자바 바이트 코드를 해당 OS의 기계어로 변환하여 실행합니다.
    
- 자바가 컴파일 되는 과정
    
    컴파일러가 자바 소스코드를 바이트 코드로 변환시킵니다. 바이트 코드는 JVM 메모리에 로드되고  JVM의 인터프리터가 바이트 코드를 해석하여 실행하거나, JIT 컴파일러가 기계어로 변환하여 실행합니다.
    
- **DI와 IoC**
    - DI(의존성 주입)는 객체가 필요로 하는 의존성을 외부에서 주입하는 패턴
    - IoC(제어의 역전)는 객체의 생성과 생명주기 관리를 프레임워크가 대신하는 것
- **Spring이란**
    
    객체를 컨테이너로 관리해주는 자바 프레임워크로 의존성 주입과 제어의 역전을 통해 결합도를 낮추는 것이 핵심입니다.
    
- **ORM(Object Relational Mapping)**
    
    관계형 데이터베이스를 OOP로 변환해주는 기술입니다. 객체지향 언어로 데이터베이스를 접근할 수 있게 도와줍니다. 또한 메소드를 호출하는 것만으로 쿼리를 수행함으로써 생산성이 향상되고 유지보수 비용이 줄어듭니다. 단점으로는 직접 SQL을 호출하는 것보다 느리고, 복잡한 쿼리는 하이버네이트로 구현하지 못한다는 점이 있습니다.
    
- **JPA**
    
    ORM을 위해 자바에서 제공하는 API입니다. 대표적인 구현체로는 하이버네이트가 있습니다.
    
- **CORS(Cross-Origin Resource Sharing)이란**
    
    CORS는 웹 브라우저에서 다른 출처(origin)의 리소스에 접근할 때 발생하는 보안 메커니즘입니다.
    웹 보안 정책 중 하나인 동일 출처 정책(Same-Origin Policy)를 우회하기 위한 메커니즘입니다. 기본적으로 브라우저는 동일 출처 정책만 허용하는데 현대 애플리케이션 특성상 다른 출처에서도 요청을 주고 받아야 하기 때문에 CORS를 사용합니다.
    
- **쿠키와 세션의 차이에 대해 설명해 주세요.**
    - 세션 방식의 로그인 과정에 대해 설명해 주세요.
        - 
    - HTTP의 특성인 Stateless에 대해 설명해 주세요.
    - Stateless의 의미를 살펴보면, 세션은 적절하지 않은 인증 방법 아닌가요?
    - 규모가 커져 서버가 여러 개가 된다면, 세션을 어떻게 관리할 수 있을까요?

---

## 네트워크

- 쿠키와 세션의 차이에 대해 설명해 주세요.
    
    **쿠키와 세션은 HTTP Stateless를 보완하기 위해 사용하는 상태 저장 방법입니다.** 
    쿠키는 클라이언트가 세션데이터를 저장하고 있고 세션은 서버가 세션데이터를 저장하고 있습니다.
     또한 쿠키는 브라우저가 종료되더라도 만료시간까지 유지되는 한편, 세션은 브라우저가 종료되면 세션쿠키도 삭제됩니다.
    
    - 세션 방식의 로그인 과정에 대해 설명해 주세요.
        - 처음 사용자가 요청을 보내면 서버는 세션ID를 만들어 저장하고 세션ID가 담겨있는 쿠키를 클라이언트에거 넘겨줍니다. 다음부터 사용자는 세션ID가 담겨있는 쿠키를 통해 요청을 보내고 서버는 세션ID를 통해 사용자를 검증합니다.
    - HTTP의 특성인 Stateless에 대해 설명해 주세요.
        - HTTP는 **Stateless 프로토콜**로, 각 요청이 독립적으로 처리되며, 서버는 이전 요청의 상태를 기억하지 않습니다. 이를 통해 서버는 확장성과 단순성을 유지할 수 있습니다.
    - Stateless의 의미를 살펴보면, 세션은 적절하지 않은 인증 방법 아닌가요?
        - 로그인과 같은 경우 애플리케이션을 이용할 때마다 매번 과정을 거치게 된다면 사용자 경험이 저해되기 때문에 Stateless와의 절충안이라 생각합니다. **JWT와 같은 토큰 기반 인증 방식을 활용**하여 HTTP의 Stateless 특성과 양립할 수 있는 방안을 채택할 수도 있습니다.
    - 규모가 커져 서버가 여러 개가 된다면, 세션을 어떻게 관리할 수 있을까요?
        - 세션마다 특정 서버로 요청하도록 조치를 취할 수 있습니다. 하지만 이런 경우 서버에 과부하가 우려되기 때문에 통상적으로는 외부 저장장치이자 In-Memory로 빠른 처리를 할 수 있는 Redis를 사용한다고 알고 있습니다.
- 2. HTTP 응답코드에 대해 설명해 주세요.
    - 401 (Unauthorized) 와 403 (Forbidden)은 의미적으로 어떤 차이가 있나요?
        - 401은 인증되지 않았거나 유효기간이 올바르지 않다는 에러를 나타내는 것이고 403은 인증은 되어있지만 해당 리소스에 대해 인가가 올바르지 않다는 에러를 나타낸 것입니다.
    - 200 (ok) 와 201 (created) 의 차이에 대해 설명해 주세요.
        - 200은 해당 요청이 올바르게 처리됐다는 것을 의미하고 201은 해당 요청이 올바르게 처리되고 새로운 리소스가 생성됐음을 의미합니다.
    - 필요하다면 저희가 직접 응답코드를 정의해서 사용할 수 있을까요? 예를 들어 285번 처럼요.
        - 네, 에러를 더 자세하게 추적하기 위해 팀에서 미리 정한 에러코드를 응답할 수 있습니다. 저 같은 경우는 프로젝트에서 도메인마다 100씩 차이를 두어 에러를 정의하고 response body로 응답하게 사용한 경험이 있습니다.
- 3. HTTP Method 에 대해 설명해 주세요.
    - HTTP Method의 멱등성에 대해 설명해 주세요.
        - 멱등성은 해당 요청이 여러번 들어와도 서버의 상태가 변함이 없음을 의미합니다.
    - GET과 POST의 차이는 무엇인가요?
        - GET은 리소스를 조회하기 위해 요청 데이터를 URL의 쿼리 파라미터에 포함하여 자원을 요청합니다. POST는 리소스를 생성하기 위한 메소드로 request body에 필요한 정보를 담아 생성을 요청합니다.
    - POST와 PUT, PATCH의 차이는 무엇인가요?
        - POST은 생성을 담당하고 PUT, PATCH는 수정을 담당합니다. PUT과 PATCH의 차이로는  PUT은 전체 데이터를 수정하는 것이고 PATCH는 변경할 데이터만 포함하여 요청보내고 요청온 데이터만 수정하는 것입니다.
    - HTTP 1.1 이후로, GET에도 Body에 데이터를 실을 수 있게 되었습니다. 그럼에도 불구하고 왜 아직도 이런 방식을 지양하는 것일까요?
        - 기존 인프라와의 호환성 때문에 그렇습니다. 예를 들어 GET 요청은 브라우저에서 캐싱하는데 캐싱은 URL 기반으로 캐싱하기 때문에 Body는 캐싱되지 않기 때문에 캐싱 동작에 혼란을 초래할 수 있습니다.
- 4. HTTP에 대해 설명해 주세요.
    
    HTTP(HyperText Transfer Protocol)는 웹에서 클라이언트와 서버 간 데이터를 주고받기 위한 프로토콜로, 요청-응답 방식으로 동작하며 기본적으로 상태를 저장하지 않는(stateless) 특성을 가집니다. 이는 단순하고 효율적이지만 보안이 요구되는 상황에서는 민감한 데이터를 보호하지 못하는 단점이 있습니다. 이를 해결하기 위해 HTTPS(HyperText Transfer Protocol Secure)가 등장했으며, 암호화를 통해 데이터의 기밀성과 무결성을 보장합니다.
    
    - 공개키와 대칭키에 대해 설명해 주세요.
        - 공개키 암호화는 두 개의 키(공개키와 개인키)를 사용하여 데이터를 암호화 및 복호화하는 방식입니다. 예를 들어, 클라이언트는 서버의 공개키로 데이터를 암호화하여 전송하고, 서버는 해당 데이터를 자신의 개인키로 복호화합니다. 공개키 암호화는 데이터를 안전하게 전달하는 데 매우 효과적이지만 처리 속도가 느리다는 단점이 있습니다. 이에 반해 대칭키 암호화는 하나의 키로 데이터를 암호화하고 복호화하는 방식으로, 처리 속도가 빠르고 대량의 데이터를 효율적으로 암호화할 수 있습니다. 예를들어, SSL/TLS handshake 과정에서 Pre-master key를 교환할 때 공개키 암호화를 사용해 클라이언트와 서버 간의 대칭키(세션 키)를 안전하게 교환한 뒤, 이후의 데이터 전송에는 대칭키 암호화를 사용합니다.
    - 왜 HTTPS Handshake 과정에서는 인증서를 사용하는 것 일까요?
        - **HTTPS Handshake 과정에서 인증서가 사용되는 이유는 클라이언트가 서버의 신뢰성을 확인하기 위해서입니다.** 인증서는 서버의 신원을 보증하는 역할을 하며, 서버의 공개키가 인증서에 포함되어 있습니다. 클라이언트는 인증서를 검증함으로써 해당 서버가 신뢰할 수 있는 인증 기관(Certificate Authority, CA)에 의해 인증된 서버임을 확인할 수 있습니다.
        **또한 클라이언트는 인증서의 공개키를 사용하여 대칭키를 암호화하여 서버로 전송함으로써 세션 키를 안전하게 교환할 수 있습니다.**
    - SSL과 TLS의 차이는 무엇인가요?
        - SSL(Secure Sockets Layer)과 TLS(Transport Layer Security)는 HTTPS에서 사용되는 암호화 프로토콜입니다. SSL은 초기 인터넷 암호화 프로토콜로, TLS는 SSL의 개선된 후속 버전입니다. TLS는   **SHA-256** 현대적인 암호화 알고리즘을 채택하여 보안을 강화하고, 성능 또한 크게 개선되었습니다. SSL 2.0과 3.0은 보안 취약점으로 인해 더 이상 사용되지 않으며, TLS 1.2와 TLS 1.3이 현재 널리 사용되는 표준입니다. TLS는 핸드셰이크 과정을 간소화하고 데이터 암호화를 더욱 안전하게 처리하여 HTTPS의 핵심 기술로 자리 잡았습니다.
        
        ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/b37f3ff4-00a6-4b4a-87d4-0c501c430e3f/caa5d5de-6f0b-490b-a1b2-de136606edfa/image.png)
        
- 5. 웹소켓과 소켓 통신의 차이에 대해 설명해 주세요. 🙊
    
    TCP나 UDP 같은 프로토콜을 기반으로 데이터를 송수신합니다. 이 방식에서는 연결을 설정하고 데이터를 교환하는 과정에서 프로그래머가 상태 관리와 데이터 처리를 직접 구현해야 하며, 다양한 네트워크 애플리케이션에서 사용됩니다.
    
    반면, 웹소켓은 HTTP 프로토콜을 업그레이드하여 양방향 통신을 지원하는 프로토콜입니다. 연결 초기에는 HTTP 핸드 쉐이크로 연결되지만, 이후에는 오버헤드 없이 통신할 수 있습니다.
    
    - 소켓과 포트의 차이가 무엇인가요?
        - 소켓(Socket)은 클라이언트와 서버 간의 데이터 송수신을 가능하게 하는 통신의 끝점(End Point)입니다. 소켓은 네트워크 프로토콜(TCP/UDP)과 IP 주소, 포트 번호의 조합으로 구성됩니다. 포트는 소켓의 한 구성 요소로, 하나의 IP 주소에서 여러 애플리케이션이 동작할 수 있도록 특정 프로세스를 구분하는 역할을 합니다. 즉, 소켓은 포트를 포함한 통신 단위를 의미하며, 포트는 데이터를 송수신할 애플리케이션을 식별하는 데 사용됩니다.
    - 여러 소켓이 있다고 할 때, 그 소켓의 포트 번호는 모두 다른가요?
        - 아니요, 여러 소켓이 있을 때 동일한 포트 번호를 사용할 수도 있습니다. 예를 들어, 서버는 특정 포트(예: 80번 포트)에서 들어오는 클라이언트 요청을 수신하고 처리합니다. 이때 서버는 포트 번호가 동일하지만 클라이언트 IP 주소와 포트 번호 조합이 다르기 때문에 여러 클라이언트와의 소켓 연결을 동시에 유지할 수 있습니다. 즉, **소켓은 IP 주소와 포트 번호의 조합으로 고유하게 식별되며**, 클라이언트와 서버 간 연결 상태를 구분합니다.
    - 사용자의 요청이 무수히 많아지면, 소켓도 무수히 생성되나요?
        - 사용자의 요청이 증가하면 서버는 요청마다 새로운 소켓을 생성하여 연결을 처리합니다. 예를 들어, 클라이언트가 서버에 요청을 보낼 때마다 서버는 클라이언트와의 통신을 담당하는 소켓을 생성합니다. 하지만 서버는 연결 유지에 필요한 리소스를 제한적으로 할당하므로, 소켓이 너무 많이 생성되면 서버의 성능에 영향을 줄 수 있습니다. 이를 방지하기 위해 서버는 적절한 연결 제한을 설정하거나, 로드 밸런싱과 같은 기술을 활용하여 요청을 효율적으로 처리합니다.
- 6. HTTP/1.1과 HTTP/2의 차이점은 무엇인가요?
    
    HTTP2.0은 HTTP 1.1의 데이터 송수신 방식과 성능을 개선한 버전입니다. 지속 연결을 처음 공식적으로 지원한 HTTP 1.1은 평문으로 메시지를 주고받는 반면, HTTP 2.0은 바이너리 데이터를 기반으로 송수신하고, 헤더 압축과 서버 푸시 기능을 제공하여 성능을 향상시켰습니다. 또한 HTTP2.0은 HTTP 멀티플렉싱을 통해 여러 요청을 병렬로 처리하여 HOL 블로킹 문제를 완화했습니다.
    
    - HOL Blocking 에 대해 설명해 주세요.
        - HOL Blocking(선두 차단) 선두의 데이터 요청이 지연되면, 뒤 따르는 데이터도 대기해야 되는 현상을 말합니다. HTTP1.1에서는 하나의 TCP 연결을 순차적으로 처리하기 때문에 HOL Blocking이 발생했습니다. HTTP/2는 하나의 TCP 연결에서 여러 요청을 병렬로 처리하는 **멀티플렉싱**을 지원하지만, TCP의 특성으로 인해 하나의 패킷 손실이 발생하면 해당 연결의 모든 스트림이 영향을 받습니다. HTTP3.0은 UDP 기반 QUIC를 도입하여 각 스트림이 독립적임을 보장합니다. UDP는 데이터의 신뢰성과 순서를 보장하지 않기 때문에 각 스트림이 독립적일 수 있습니다. 대신, 애플리케이션 단에서 데이터 순서와 일관성을 보장합니다.
    - HTTP/3.0의 주요 특징에 대해 설명해 주세요.
        - QUIC프로토콜, 멀티플렉싱, 0-RTT 핸드쉐이크 지원
- 7. TCP와 UDP의 차이에 대해 설명해 주세요.
    
    TCP는 연결지향 프로트콜이고 신뢰성과 순서를 보장합니다. UDP에 비해 상대적으로 느립니다. UDP는 비연결지향 프로트콜이고 신뢰성과 순서를 보장하지 않습니다.
    
    - Checksum이 무엇인가요?
        - 데이터 전송 중 무결성을 판별하기 위한 값입니다. 데이터를 가공하여 checksum을 만들어 보내고 수신측에서 동일한 계산을 수행하여 checksum값이 같은지 확인합니다.
    - TCP와 UDP 중 어느 프로토콜이 Checksum을 수행할까요?
        - TCP, UDP 모두 checksum을 사용합니다. UDP는 신뢰성을 보장하지는 않지만 오류를 검증하는 무결성은 보장하기 때문입니다. (+ 신뢰성은 무결성 + 장애복구)
    - 그렇다면, Checksum을 통해 오류를 정정할 수 있나요?
        - checksum은 데이터 오류 검출 메커니즘이고 정정할 수는 없습니다. checksum은 데이터의 요약정보이기 때문에 이를 통해 복구는 할 수 없습니다.
    - TCP가 신뢰성을 보장하는 방법에 대해 설명해 주세요.
        - 데이터의 시퀀스 번호를 사용하여 데이터가 순서대로 도착하도록 보장합니다. 또한 수신측에서 ACK응답을 받기 때문에 ACK응답을 받지 못한 데이터는 재전송합니다.
    - TCP의 혼잡 제어 처리 방법에 대해 설명해 주세요.
        - slow start: 윈도우 크기 1로 시작하고 이후 지수적으로 증가합니다. 만약 이 때 혼잡이 발생한다면 1로 다시 떨어지고 혼잡 임계점의 절반까지 지수적으로 다시 증가합니다. 이후 +1처럼 선형적으로 증가합니다. 이를 혼잡회피 단계라고 합니다. 혼잡회피 단계에서 혼잡이 감지되면 윈도우 크기를 절반으로 감소시킵니다.
        또한 동일한 ACK를 세 번 응답 받으면 손실된 패킷이 있다고 감지하고 빠르게 손실된 패킷을 재전송합니다.
    - 왜 HTTP는 TCP를 사용하나요?
        - 데이터의 신뢰성과 순서를 보장하기 위해 TCP를 사용합니다. 웹 페이지는 스크립트, 이미지 등 다양한 리소스를 포함하며, 데이터 손실이 있으면 제대로 렌더링 되지 않기 때문입니다.
    - 그렇다면, 왜 HTTP/3 에서는 UDP를 사용하나요? 위에서 언급한 UDP의 문제가 해결되었나요?
        - HOL Blocking 문제를 해결하기 위해 스트림 UDP를 사용합니다. 데이터의 신뢰성과 순서를 보장하지 않기 때문에 각 스트림은 독립적일 수 있습니다. UDP의 문제인 데이터의 신뢰성과 순서 문제를 애플리케이션 단에서 순서를 조립함으로 해결하였습니다.
    - 그런데, 브라우저는 어떤 서버가 TCP를 쓰는지 UDP를 쓰는지 어떻게 알 수 있나요?
        - **예: 서버가 HTTP/3(UDP)를 지원하는 경우**
        1. 브라우저는 **DNS 조회**를 통해 HTTPS 레코드에서 HTTP/3 지원 여부를 확인.
        2. TLS 핸드셰이크에서 **ALPN 협상**으로 HTTP/3를 결정.
        3. 브라우저는 **UDP 연결**을 사용해 데이터 송수신.
        
        ### **예: 서버가 HTTP/3를 지원하지 않는 경우**
        
        1. 브라우저는 **DNS 조회**에서 HTTP/3 지원 여부를 확인하지 못함.
        2. TLS 핸드셰이크에서 **ALPN 협상**으로 HTTP/2 또는 HTTP/1.1 결정.
        3. 브라우저는 **TCP 연결**을 사용해 데이터 송수신.
    - 본인이 새로운 통신 프로토콜을 TCP나 UDP를 사용해서 구현한다고 하면, 어떤 기준으로 프로토콜을 선택하시겠어요?
        - 데이터 손실이 허용되지 않는 경우 TCP를 사용할 것입니다. 예를 들어, 은행 송금, 이메일이 있을 수 있습니다. 약간의 데이터 손실을 허용하고 속도를 중요시 한다면 UDP를 사용할 것입니다. 실시간 게임이 있을 수 있을 수 있습니다. 데이터 손실도 허용되지 않고 속도도 중요시 한다면 QUIC나 webRTC를 사용할 수 있습니다.
- 
- 8. DHCP가 무엇인지 설명해 주세요.
    - DHCP는 몇 계층 프로토콜인가요?
    - DHCP는 어떻게 동작하나요?
    - DHCP에서 UDP를 사용하는 이유가 무엇인가요?
    - DHCP에서, IP 주소 말고 추가로 제공해주는 정보가 있나요?
    - DHCP의 유효기간은 얼마나 긴가요?
- 9. IP 주소는 무엇이며, 어떤 기능을 하고 있나요?
    - IPv6는 IPv4의 주소 고갈 문제를 해결하기 위해 만들어졌지만, 아직도 수많은 기기가 IPv4를 사용하고 있습니다. 고갈 문제를 어떻게 해결할 수 있을까요?
    - IPv4와 IPv6의 차이에 대해 설명해 주세요.
    - 수많은 사람들이 유동 IP를 사용하고 있지만, 수많은 공유기에서는 고정 주소를 제공하는 기능이 이미 존재합니다. 어떻게 가능한 걸까요?
    - IPv4를 사용하는 장비와 IPv6를 사용하는 같은 네트워크 내에서 통신이 가능한가요? 가능하다면 어떤 방법을 사용하나요?
    - IP가 송신자와 수신자를 정확하게 전송되는 것을 보장해 주나요?
    - IPv4에서 수행하는 Checksum과 TCP에서 수행하는 Checksum은 어떤 차이가 있나요?
    - TTL(Hop Limit)이란 무엇인가요?
    - IP 주소와 MAC 주소의 차이에 대해 설명해 주세요.
- 10. OSI 7계층에 대해 설명해 주세요.
    - Transport Layer와, Network Layer의 차이에 대해 설명해 주세요.
    - L3 Switch와 Router의 차이에 대해 설명해 주세요.
    - 각 Layer는 패킷을 어떻게 명칭하나요? 예를 들어, Transport Layer의 경우 Segment라 부릅니다.
    - 각각의 Header의 Packing Order에 대해 설명해 주세요.
    - ARP에 대해 설명해 주세요.
- 11. 3-Way Handshake에 대해 설명해 주세요.
    - ACK, SYN 같은 정보는 어떻게 전달하는 것 일까요?
    - 2-Way Handshaking 를 하지않는 이유에 대해 설명해 주세요.
    - 두 호스트가 동시에 연결을 시도하면, 연결이 가능한가요? 가능하다면 어떻게 통신 연결을 수행하나요?
    - SYN Flooding 에 대해 설명해 주세요.
    - 위 질문과 모순될 수 있지만, 3-Way Handshake의 속도 문제 때문에 이동 수를 줄이는 0-RTT 기법을 많이 적용하고 있습니다. 어떤 방식으로 가능한 걸까요?
- 12. 4-Way Handshake에 대해 설명해 주세요.
    - 패킷이 4-way handshake 목적인지 어떻게 파악할 수 있을까요?
    - 빨리 끊어야 할 경우엔, (즉, 4-way Handshake를 할 여유가 없다면) 어떻게 종료할 수 있을까요?
    - 4-Way Handshake 과정에서 중간에 한쪽 네트워크가 강제로 종료된다면, 반대쪽은 이를 어떻게 인식할 수 있을까요?
    - 왜 종료 후에 바로 끝나지 않고, TIME_WAIT 상태로 대기하는 것 일까요?
- 13. www.github.com을 브라우저에 입력하고 엔터를 쳤을 때, 네트워크 상 어떤 일이 일어나는지 최대한 자세하게 설명해 주세요.
    - DNS 쿼리를 통해 얻어진 IP는 어디를 가리키고 있나요?
    - Web Server와 Web Application Server의 차이에 대해 설명해 주세요.
    - URL, URI, URN은 어떤 차이가 있나요?
- 14. DNS에 대해 설명해 주세요.
    - DNS는 몇 계층 프로토콜인가요?
    - UDP와 TCP 중 어떤 것을 사용하나요?
    - DNS Recursive Query, Iterative Query가 무엇인가요?
    - DNS 쿼리 과정에서 손실이 발생한다면, 어떻게 처리하나요?
    - 캐싱된 DNS 쿼리가 잘못 될 수도 있습니다. 이 경우, 어떻게 에러를 보정할 수 있나요?
    - DNS 레코드 타입 중 A, CNAME, AAAA의 차이에 대해서 설명해주세요.
    - hosts 파일은 어떤 역할을 하나요? DNS와 비교하였을 때 어떤 것이 우선순위가 더 높나요?
- 15. SOP 정책에 대해 설명해 주세요.
    - CORS 정책이 무엇인가요?
    - Preflight에 대해 설명해 주세요.
- 16. Stateless와 Connectionless에 대해 설명해 주세요.
    - 왜 HTTP는 Stateless 구조를 채택하고 있을까요?
    - Connectionless의 논리대로면 성능이 되게 좋지 않을 것으로 보이는데, 해결 방법이 있을까요?
    - TCP의 keep-alive와 HTTP의 keep-alive의 차이는 무엇인가요?
- 17. 라우터 내의 포워딩 과정에 대해 설명해 주세요.
    - 라우팅과 포워딩의 차이는 무엇인가요?
    - 라우팅 알고리즘에 대해 설명해 주세요.
    - 포워딩 테이블의 구조에 대해 설명해 주세요.
- 18. 로드밸런서가 무엇인가요?
    - L4 로드밸런서와, L7 로드밸런서의 차이에 대해 설명해 주세요.
    - 로드밸런서 알고리즘에 대해 설명해 주세요.
    - 로드밸런싱 대상이 되는 장치중 일부 장치가 문제가 생겨 접속이 불가능하다고 가정해 봅시다. 이 경우, 로드밸런서가 해당 장비로 요청을 보내지 않도록 하려면 어떻게 해야 할까요?
    - 로드밸런서 장치를 사용하지 않고, DNS를 활용해서 유사하게 로드밸런싱을 하는 방법에 대해 설명해 주세요.
- 19. 서브넷 마스크와, 게이트웨이에 대해 설명해 주세요.
    - NAT에 대해 설명해 주세요.
    - 서브넷 마스크의 표현 방식에 대해 설명해 주세요.
    - 그렇다면, 255.0.255.0 같은 꼴의 서브넷 마스크도 가능한가요?
- 20. 멀티플렉싱과 디멀티플렉싱에 대해 설명해 주세요.
    - 디멀티플렉싱의 과정에 대해 설명해 주세요.
- 21. XSS에 대해서 설명해 주세요.
    
    
    - CSRF랑 XSS는 어떤 차이가 있나요?
    - XSS는 프론트엔드에서만 막을 수 있나요?

---

## 데이터베이스

- 1. Key (기본키, 후보키, 슈퍼키 등등...) 에 대해 설명해 주세요.
    
    슈퍼키는 유일성을 만족하는 키, 후보키는 유일성과 최소성을 만족하는 키, 대체 키는 기본 키로 선택되지 않은 후보 키를 지칭, 기본키는 후보키중 선택 된 키, 외래키는 다른 테이블의 값을 참조하기 위한 키
    
    - 기본키는 수정이 가능한가요?
        - 네 가능합니다. 그러나 다른 테이블에서 외래키로 참조중이라면 수정이 불가능합니다. CASCADE 옵션을 사용하면 참조하는 데이터도 함께 수정이 가능합니다.
    - 사실 MySQL의 경우, 기본키를 설정하지 않아도 테이블이 만들어집니다. 어떻게 이게 가능한 걸까요?
        - InnoDB에서는 숨겨진 rowID를 생성합니다. InnoDB는 클러스터링 구조를 가지고 있기 때문에 자동으로 생성하는 것입니다.
    - 외래키 값은 NULL이 들어올 수 있나요?
        - 네 들어갈 수 있습니다. NULL이 허용되지 않게 하려면 NOT NULL 제약조건을 추가할 수도 있습니다.
    - 어떤 칼럼의 정의에 UNIQUE 키워드가 붙는다고 가정해 봅시다. 이 칼럼을 활용한 쿼리의 성능은 그렇지 않은 것과 비교해서 어떻게 다를까요?
        - UNIQUE 키워드가 붙는다면 자동으로 인덱스가 생성되기 때문에 읽기 성능이 향상됩니다. 그러나 입력/수정 기능이 저하됩니다.
- **2. RDB와 NoSQL의 차이에 대해 설명해 주세요.**
    
    RDB는 스키마가 고정되 있고 ACID 트랜잭션을 제공합니다. NoSQL은 스키마가 정해져 있지 않아 유연한 데이터 구조 변경이 가능하고, 트랜잭션 지원이 제한적입니다. 그래서 데이터 일관성이 중요하다면 RDB를 사용하고 데이터 가용성이 중요하다면 NoSQL을 사용합니다.
    
    - NoSQL의 강점과, 약점이 무엇인가요?
        - NoSQL은 대규모 데이터 처리를 효율적으로 수행할 수 있는 장점이 있습니다. 이는 수평적 확장을 통해 성능을 향상시킬 수 있기 때문입니다.
        - 약점은 데이터 일관성 보장이 어렵다는 것입니다. 데이터가 중복되는 경우도 많고, 트랜잭션 지원을 하지 않기 때문입니다.
    - RDB의 어떠한 특징 때문에 NoSQL에 비해 부하가 많이 걸릴 "수" 있을까요? (주의: 무조건 NoSQL이 RDB 보다 빠르다라고 생각하면 큰일 납니다!)
        - 복잡한 조인 연산과, 트랜잭션 때문입니다.
    - NoSQL을 활용한 경험이 있나요? 있다면, 왜 RDB를 선택하지 않고 해당 DB를 선택했는지 설명해 주세요.
- **3. 트랜잭션이 무엇이고, ACID 원칙에 대해 설명해 주세요.**
    
    트랜잭션은 데이터 ACID 원칙을 준수하기 위한 기능입니다. A는 Atomicity으로 원자성을 뜻하고 트랜잭션 전체가 성공하거나 실패하는 것을 의미합니다. c는 consequenrcy로 데이터 일관성을 뜻하고, 데이터베이스가 트랜잭션 전후 같다는 것을 의미합니다. I는 isolation으로 격리성으로 트랜잭션들이 서로 영향을 끼칠 수 없음을 보장함을 의미합니다.  D는 Durability로 지속성으로 트랜잭션이 성공적으로 완료된 후에는 시스템 장애가 발생해도 변경 사항이 영구적으로 저장됩니다. 
    
    - ACID 원칙 중, Durability를 DBMS는 어떻게 보장하나요?
        - 트랜잭션 수행 중 변경사항이 발생하면 WAL(Write ahead Loggin)과 같은 로그 파일에 먼저 기록합니다. 장애가 발생하더라도 로그 파일을 기반으로 복구할 수 있습니다.( InnoDb, 리두 로그)
    - 트랜잭션을 사용해 본 경험이 있나요? 어떤 경우에 사용할 수 있나요?
        - 입금과 출금은 원자성이 보장되어야 하기 때문에 트랜잭션을 사용할 수 있습니다.
    - 읽기에는 트랜잭션을 걸지 않아도 될까요?
        - 네, 읽기 작업에서는 트랜잭션을 꼭 걸 필요는 없지만, 데이터 일관성을 보장하기 위해 데이터를 수정이나 삭제하지 못하도록 높은 격리수준의 트랜잭션을 걸 수도 있습니다.
- **4. 트랜잭션 격리 레벨에 대해 설명해 주세요.**
    
    READ UNCOMIITED는  커밋되지 않은 데이터도 읽을 수 있음을 의미합니다. READ COMMITED는 커밋된 데이터만 읽을 수 있음을 의미합니다. READ UNCOMMITED에서 발생 가능한 DIRTY READ(다른 트랜잭션이 롤백한 데이터를 읽을 가능성)를 해결합니다. REPEATABLE READ는 트랜잭션 시작 후 읽은 데이터를 끝날 때까지 동일함을 보장해줍니다. MySQL InnoDB에서는 기본 격리 수준으로 사용됩니다. READ COMMITED에서 발생할 수 있는 Non-Repeatable Read(같은 트랜잭션 내에서 동일한 데이터를 두번 읽을 때 다를 수 있음)을 해결해줍니다. 가장 높은 격리수준인 Serializable은 모든 트랜잭션이 순차적으로 직렬화되는 것처럼 실행합니다. REPEATABLE READ에서 발생하는 Phantom Read(트랜잭션 중간에 다른 트랜잭션이 새로운 행을 추가하거나 삭제하면, 검색 결과가 달라질 수 있음.)을 해결할 수 있습니다.
    
    - 모든 DBMS가 4개의 레벨을 모두 구현하고 있나요? 그렇지 않다면 그 이유는 무엇일까요?
        - **DBMS의 설계 목표에 따라 차이가 있음, 일부 격리 수준은 특정 아키텍처와 호환되지 않음**:
    - 만약 MySQL을 사용하고 있다면, (InnoDB 기준) Undo 영역과 Redo 영역에 대해 설명해 주세요.
        - undo 영역은 변경되기 전 기존의 데이터를 보관합니다. 이로 인해 MVCC를 구현할 수 있습니다. Redo 영역은 장애시 복구하는데 쓰입니다. 데이터 변경 기록을 저장함으로써 장애가 나더라도 redo 영역을 토대로 복구할 수 있습니다.
    - 그런데, 스토리지 엔진이 정확히 무엇을 하는 건가요?
        - **스토리지 엔진**은 데이터가 물리적으로 저장되고 검색되는 방식을 결정하는 소프트웨어
- **5. 인덱스가 무엇이고, 언제 사용하는지 설명해 주세요.**
    - 일반적으로 인덱스는 수정이 잦은 테이블에선 사용하지 않기를 권합니다. 왜 그럴까요?
    - 앞 꼬리질문에 대해, 그렇다면 인덱스에서 사용하지 않겠다고 선택한 값은 위 정책을 그대로 따라가나요?
    - ORDER BY/GROUP BY 연산의 동작 과정을 인덱스의 존재여부와 연관지어서 설명해 주세요.
    - 기본키는 인덱스라고 할 수 있을까요? 그렇지 않다면, 인덱스와 기본키는 어떤 차이가 있나요?
    - 그렇다면 외래키는요?
    - 인덱스가 데이터의 물리적 저장에도 영향을 미치나요? 그렇지 않다면, 데이터는 어떤 순서로 물리적으로 저장되나요?
    - 우리가 아는 RDB가 아닌 NoSQL (ex. Redis, MongoDB 등)는 인덱스를 갖고 있나요? 만약 있다면, RDB의 인덱스와는 어떤 차이가 있을까요?
    - (A, B) 와 같은 방식으로 인덱스를 설정한 테이블에서, A 조건 없이 B 조건만 사용하여 쿼리를 요청했습니다. 해당 쿼리는 인덱스를 탈까요?
- **6. RDBMS, NoSQL에서의 클러스터링/레플리케이션 방식에 대해 설명해 주세요.**
    - 이러한 분산 환경에선, 트랜잭션을 어떻게 관리할 수 있을까요?
    - 마스터, 슬레이브 데이터 동기화 전 까지의 데이터 정합성을 지키는 방법은 무엇이 있을까요?
    - 다중 트랜잭션 상황에서의 Deadlock 상황과, 이를 해결하기 위한 방법에 대해 설명해 주세요.
    - 샤딩 방식은 무엇인가요? 만약 본인이 DB를 분산해서 관리해야 한다면, 레플리케이션 방식과 샤딩 방식 중 어떤 것을 사용할 것 같나요?
- **7. 정규화가 무엇인가요?**
    - 정규화를 하지 않을 경우, 발생할 수 있는 이상현상에 대해 설명해 주세요.
    - 각 정규화에 대해, 그 정규화가 진행되기 전/후의 테이블의 변화에 대해 설명해 주세요.
    - 정규화가 무조건 좋은가요? 그렇지 않다면, 어떤 상황에서 역정규화를 하는게 좋은지 설명해 주세요.
- **8. View가 무엇이고, 언제 사용할 수 있나요?**
    - 그렇다면, View의 값을 수정해도 실제 테이블에는 반영되지 않나요?
- **9. DB Join이 무엇인지 설명하고, 각각의 종류에 대해 설명해 주세요.**
    - 사실, JOIN은 상당한 시간이 걸릴 수 있기에 내부적으로 다양한 구현 방식을 사용하고 있습니다. 그 예시에 대해 설명해 주세요.
    - 그렇다면 입력한 쿼리에서 어떤 구현 방식을 사용하는지는 어떻게 알 수 있나요?
    - 앞 질문들을 통해 인덱스의 중요성을 알 수 있었는데, 그렇다면 JOIN의 성능도 인덱스의 유무의 영향을 받나요?
    - 3중 조인 부터는 동작 방식이 약간 바뀝니다. 어떻게 동작하는지, 그리고 그 방식이 성능에 어떠한 영향을 주는지 설명해 주세요.
- **10. B-Tree와 B+Tree에 대해 설명해 주세요.**
    - 그렇다면, B+Tree가 B-Tree에 비해 반드시 좋다고 할 수 있을까요? 그렇지 않다면 어떤 단점이 있을까요?
    - DB에서 RBT를 사용하지 않고, B-Tree/B+Tree를 사용하는 이유가 있을까요?
    - 오름차순으로 정렬된 인덱스가 있다고 할 때, 내림차순 정렬을 시도할 경우 성능이 어떻게 될까요? B-Tree/B+Tree의 구조를 기반으로 설명해 주세요.
- **11. DB Locking에 대해 설명해 주세요.**
    - Optimistic Lock/Pessimistic Lock에 대해 설명해 주세요.
    - 물리적인 Lock을 건다면, 만약 이를 수행중인 요청에 문제가 생겨 비정상 종료되면 Lock이 절대 해제되지 않는 문제가 생길 수도 있을 것 같습니다. DB는 이를 위한 해결책이 있나요? 없다면, 우리가 이 문제를 해결할 수 없을까요?
- **12. 트래픽이 높아질 때, DB는 어떻게 관리를 할 수 있을까요?**
    - DB 서버를 분산하지 않고, 트래픽을 감당할 수 있는 방법은 없을까요?
- **13. Schema가 무엇인가요?**
    
    스키마(Schema)는 데이터베이스에서 **데이터 구조, 제약 조건, 관계**를 정의하는 설계도나 청사진 역할을 합니다. 
    
    - Schema의 3계층에 대해 설명해 주세요.
- **14. DB의 Connection Pool에 대해 설명해 주세요.**
    - DB와 Client가 Connection을 어떻게 구성하는지 설명해 주세요.
- **15. Table Full Scan, Index Range Scan에 대해 설명해 주세요.**
    - 가끔은 인덱스를 타는 쿼리임에도 Table Full Scan 방식으로 동작하는 경우가 있습니다. 왜 그럴까요?
    - COUNT (개수를 세는 쿼리) 는 어떻게 동작하나요? COUNT(1), COUNT(*), COUNT(column) 의 동작 과정에는 차이가 있나요?
- **16. SQL Injection에 대해 설명해 주세요.**
    - 그렇다면, 우리가 서버 개발 과정에서 사용하는 수많은 DB 라이브러리들은 이 문제를 어떻게 해결할까요?

## 개발상식, 기타

- 1. 가상화가 무엇이고, 이것이 가상머신과 어떠한 차이가 있는지 설명해 주세요.
    - 그렇다면 Docker는 둘 중 어디에 속하나요? 왜 사람들이 Docker를 많이 채택할까요?
    - 하나의 Host OS에서 돌아간다면 충분히 한 컨테이너가 다른 컨테이너에 간섭할 수 있는 위험이 있지 않을까요? 이를 어떻게 방어할 수 있을까요?
    - Docker 위에 Docker를 올릴 순 없을까요?
- 2. CI/CD 를 사용해 본 경험이 있나요? 있다면 간단하게 설명해 주세요.
    
    ### 
    
- 3. static 키워드는 어떤 의미를 갖나요? (본인이 사용하는 언어에서 없다면 패스...)
    - 컴파일 할 때, static 키워드가 붙은 변수, 함수는 어떻게 처리되나요?
    - Java에서 static과 static final은 어떤 차이를 갖나요? final과 static final은요?
- 4. 객체지향 프로그래밍이 무엇인가요?
    - SOLID 원칙에 대해 설명해 주세요.
    - 다형성이 무엇인지 설명하고, 동적 다형성과 정적 다형성이 무엇인지 설명해 주세요.
    - 오버로딩과 오버라이딩의 차이에 대해 설명해 주세요.
    - 클래스가 있는 언어는 반드시 객체지향 언어라고 할 수 있을까요? 그 반대는 성립하나요?
- **5. 프레임워크와 라이브러리의 차이에 대해 설명해 주세요.**
- 6. Call By Value와 Call By Reference의 차이를 본인의 언어를 기반으로 설명해 주세요.
- 7. 순수함수가 무엇인지를 함수형 프로그래밍 매커니즘과 연관지어 설명해 주세요.
    - Side Effect가 무엇인가요? 이를 모두 없애는 프로그래밍이 이상적이라고 할 수 있을까요?
    - 왜 함수형 프로그래밍 매커니즘을 사용한다고 생각하시나요?
    - 순수함수는 Thread Safe 한가요? 왜 그럴까요?
    - 고차함수에 대해 설명해 주세요.
- 8. MVC 패턴이 무엇인가요?
    - 다른 아키텍쳐 패턴은 없나요? MVC랑 비교해서 어떤 차이가 있나요?
- 9. 디자인 패턴이 무엇인지 설명해주고, 대표적인 디자인 패턴에 대해 설명해 주세요.
    - Singleton의 장단점에 대해 설명해 주세요.
    - Singleton이 하나의 객체를 생성한다는 것을 어떻게 보장할 수 있을까요?
- 10. GC에 대해 설명해 주세요.
    - 본인이 사용하는 언어에서는 GC를 어떻게 구현했나요?
    - GC의 장단점에 대해 설명해 주세요.
    - GC는 어떤 영역에 있는 데이터를 관리하나요?
    - Reference Counting 방식에 대해 설명하고, 이 알고리즘에서 발생할 수 있는 순환 참조 및 Retain Cycle에 대해 설명해 주세요.
- 11. 32비트와 64비트의 차이는 무엇인가요?
    - 32비트에서 가용한 메모리의 크기는 최대 4GB라고 하는데, 왜 그런걸까요?
- 12. 인증과 인가의 차이에 대해 설명해 주세요.
    - OAuth가 무엇인지 설명하고, 이것은 인증인지 인가인지에 대해 설명해 주세요.
- 13. JWT 인증 방식이 무엇인가요?
    - Signature는 어떻게 만들어지나요?
        - JWT의 헤더와 페이로드를 각가 인코딩하고 점을 구별하고 자신만의 시크릿 키값으로 암호화하여 만들어집니다.
    - 만약 Access Token이 탈취되면, 어떻게 대응할 수 있을까요?
        - Access Token을 무효화 시키거나 아니면 애초에 유효시간을 짧게 가져갈 수 있습니다. 그러나 Access Token 유효시간이 짧아지면 UX 경험이 저하되기 때문에 유효시간이 긴 Refresh Token을 도입하는 방향을 생각할 수 있습니다.
    - 반대로 Refresh Token이 탈취되면, 어떻게 대응해야 할까요?
- 14. 암호화 알고리즘에 대해 설명해 주세요.
- 15. 문자열 인코딩에 대해 설명해 주세요.
    - Base64 인코딩은 일반적인 문자열 인코딩과는 달리, 사용자가 읽기 어려운 알파벳과 숫자 조합으로 변경합니다. 이를 사용하는 이유는 무엇일까요?
        - 사용자가 읽기 어렵지만 전송시 데이터 손상이 없게 하기 위해 Base64 인코딩을 사용합니다.
- 16. Git에 대해 설명해 주세요.
    - 여러 브랜치를 합쳐야 할 때, 어떤 방법을 사용할 수 있는지 "모두" 설명해 주세요.
    - 여러 브랜치를 합쳐야 할 때, 어떤 방법을 사용할 수 있는지 "모두" 설명해 주세요.
