****Queue**의 구조는 한쪽에서는 삽입만 일어나고 한쪽에서는 삭제만 하는 자료구조 입니다. 즉, 먼저 들어간 것이 먼저 나오는 FIFO 구조입니다.** 

**앞과 뒤 전부에서 삽입 삭제가 가능한 Deque도 있습니다.   
  
Queue와 Deque의 인터페이스를 구현하는 대표적인 두 가지 클래스는 LinkedList와 ArrayDeque가 있습니자.**

**큐를 배열이 아닌 LinkedList로 구현한 이유**

 요소의 추가 및 제거 시 기존 배열을 재구성할 필요 없이 노드의 연결만 변경하면 됩니다. 이로 인해 요소의 추가 및 제거(특히, 앞/뒤)가 상수 시간(O(1))에 이루어집니다.

이유가 뭔가하면 배열로 구현한 큐의 경우 내부에서 Object\[\] 배열을 담고있고, 요소가 배열에 들어있는 양에 따라 용적(배열 크기)을 줄이거나 늘려주어야 하고, 큐를 선형적인 큐로 구현했을 경우 요소들이 뒤로 쏠리기 때문에 이러한 문제를 효율적으로 극복하고자 원형 형태로 구현하는데 이 구현이 고려해야 할 점도 많고 조금 복잡하다.

하지만 배열 대신 연결리스트로 구현하게 될 경우 위와같은 단점들이 해결된다. 각 데이터들을 노드(node) 객체에 담고 노드 간 서로 연결해주기 때문에 배열처럼 요소 개수에 따라 늘려주거나 줄여줄 필요도 없고 삽입, 삭제 때는 연결 된 링크만 끊어주거나 이어주면 되기 때문에 관리면에서도 편하다. 

---

**여기서부터는 중요하니 꼭 기억했으면 좋겠다.**

******LinkedList******

-   앞, 뒤 노드를 참조하고 있어 배열, ArrayDeque보다 상대적으로 오버헤드가 있음
-   요소들이 연속적으로 메모리 할당이 되어있지 않음

****ArrayDeque****

-   원형버퍼(배열)로 구성되어있다.
-   요소들이 연속적으로 메모리 할당 되어있음   <---배열에 의한 효과
-   JVM이 최적화 해줌                                         <---배열에 의한 효과
-   배열보다는 약간의 오버헤드가 있음 
    -   앞(head), 뒤(tail) 포인터 가지고 있음
    -   경계검사

**Deque의 크기가 변하지 않을 때 어떤 ADT를 사용해야 할까?**

**ArrayDeque는 원형버퍼 즉, 배열로 구성되어있다.** 연속적으로 메모리가 할당된 배열은 엑세스하는 데 효율적이다. 또한 JVM은 배열에서 반복적인 작업은 최적화해주기 때문에 LinkedList보다 빠르다. 또한 LinkedList는 앞,뒤 노드들을 참조하기 때문에 메모리를 더 많이 사용한다. 객체 생성, 참조 비용 때문에 배열인 **ArrayDeque를 사용하는 것이 더 좋다.** 

### **결론**

-   **ArrayDeque를 사용할 때**:
    -   **덱의 크기가 고정되고 양 끝에서 효율적인 삽입과 삭제가 필요할 때.**
-   **LinkedList를 사용할 때**:
    -   **덱의 크기가 자주 그리고 크게 변하고, 삽입과 삭제가 자주 발생할 때.**
-   **일반 배열을 사용할 때**:
    -   **덱의 크기가 고정될 때**
