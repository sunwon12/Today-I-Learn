## **#문제**         

**레벨: G2  
알고리즘: dp + 비트마스킹**   
**풀이시간: 1시간  
힌트 참조 유무: 유**

[https://www.acmicpc.net/problem/1562](https://www.acmicpc.net/problem/1562)

![image](https://github.com/user-attachments/assets/a2ff1c27-c574-46d0-bded-f7a4f51e13e4)

---

## **#문제 풀이**        

dfs를 풀어야 한다는 건 어렴풋 짐작할 수 있다. 그러나 N= 100일 때, 100 자리에 10개(0 ~ 9)를 넣는다고 생각하면 

10 ^ 100 의 작업 수가 필요하다. 당연히 이렇게 해서는 안된다. dfs 풀이가 확고할 때는 dp 도입을 생각해본다.

---

## **#풀이 코드**      

```
import java.io.*;

public class Main {
    static final int MOD = 1_000_000_000;
    static final int FULL_MASK = (1 << 10) - 1;
    static long[][][] dp = new long[101][10][1 << 10];

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int N = Integer.parseInt(br.readLine());

        long result = 0;
        for (int i = 1; i <= 9; i++) {
            result = (result + solve(N, i, 1 << i)) % MOD;
        }

        System.out.println(result);
    }

    static long solve(int n, int lastDigit, int usedMask) {
        if (n == 1) {
            return usedMask == FULL_MASK ? 1 : 0;
        }

        if (dp[n][lastDigit][usedMask] != 0) {
            return dp[n][lastDigit][usedMask];
        }

        long count = 0;
        if (lastDigit > 0) {
            count = (count + solve(n - 1, lastDigit - 1, usedMask | (1 << (lastDigit - 1)))) % MOD;
        }
        if (lastDigit < 9) {
            count = (count + solve(n - 1, lastDigit + 1, usedMask | (1 << (lastDigit + 1)))) % MOD;
        }

        return dp[n][lastDigit][usedMask] = count;
    }
}
```
