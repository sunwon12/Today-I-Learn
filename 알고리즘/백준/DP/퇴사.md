### **문제**         

**레벨:    
알고리즘: dp**  
**풀이시간: 3:05  
힌트 참조 유무:**

[https://www.acmicpc.net/problem/14501](https://www.acmicpc.net/problem/14501)

![image](https://github.com/sunwon12/Today-I-Learn/assets/92251131/ffd4374b-6524-4f47-bad9-846e2b603e12)

### **1 번째 시도**   

**\[알고리즘 설명\]**

최단 기간내에 최상의 이익을 봐야 하는 이문제는 dp의 대표문제이다.   
우리는 기준을 두개로 나눌 수 있습니다. 일수, 탐색한 스케줄의 수.  
  

```
7
3 10
5 20
1 10
1 20
2 15
4 40
2 200
```

위 dp 문제는 일반적인 최소한의 일수로 최대치값을 구하는 문제와 다르다는 인지하고 들어가야 한다. 주어진 일수와 탐색 색 스케줄 두개를 기준으로 dp를 업데이트 해가는 것이 아닌 주어진 일수, 탐색 스케줄을 한 번에 묶어서 기준 한 개로 탐색해야 한다. **(새로운 유형)**

그래서 dp의 인덱스 0에서부터 채우는 것이 아닌 N에서부터 0으로 탐색하는 것도 특이점 중 하나이다.  
헷갈리지 마시오.  
dp\[i\]는 i일까지의 최대치가 아니라 i부터 N일 까지의 최대치이다. 이렇게 하는 이유는 기존 dp방식으로 한다면 dp\[N\]의 값이 dp\[N-1\]의 값의 영향을 미칠 수 있기 때문이다. 예를 들면, 6일차까지 탐색했을 때 5일의 스케쥴을 받는 게 최대치였다면 7일차를 탐색했을 때 5일차의 스케줄을 안해야 하지만 7일차를 할 수 있다. 7일차가 극단적으로 값이 크다면 5일차를 안 하고 7일차를 하는 것이 맞다. 그렇다면 dp이전 값은 쓸모없어지는 것이다. dp란 전의 값을 참조해서 채워가는 방식인데 이전 방식이 쓸데없어진다? 이러한 사고의 틈을 메꾸기 위해 거꾸로 채워가는 것이다. 

dp는 점화식을 세우는 것이 중요하다.  
dp\[i\]\[j\] = dp\[i\]\[j\]

dp 뒤에서부터   
dp 문제를 풀 때   
이해하기 쉽게 시간 배열 따로 금액 배열 따로 만드는 것이 편할 것이다.  
또 하나, dp는 바텀업 방식과  탑다운 방식이 있는데 점화식 세우기 편한 대로 선택해서 구현하면 된다.

```
import java.io.*;
import java.util.*;

public class Main {
	
	static int max=0;
	public static void main(String[] args) throws IOException {
		Scanner sc = new Scanner(System.in);
		int Case = sc.nextInt();
		int[] T = new int[Case];//소요 기간
		int[] P = new int[Case];//금액
		for(int i=0;i<Case;i++) {
			T[i]=sc.nextInt();	
			P[i]=sc.nextInt();	
		}//for
		
		int[] dp = new int[Case+1];
		
		for(int i=0;i<Case;i++) {
			 if(i+T[i]<=Case) {	//범위에 벗어나지 않는다면 
				 dp[i+T[i]]=Math.max(dp[i+T[i]],dp[i]+P[i]);	
			 }//if
			 dp[i+1]=Math.max(dp[i+1],dp[i]);	//다음dp=현재 누적값vs 다음 누적값
			 
		}//for	
		System.out.println(dp[Case]);	
	}//main()
	
}
```
